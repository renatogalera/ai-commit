// Package ui contains the implementation of the interactive terminal UI (TUI)
// for AI-Commit. This UI lets users view, edit, regenerate, and confirm the AI-
// generated commit message before performing the commit.
package ui

import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/charmbracelet/bubbles/spinner"  // For spinner animations.
	"github.com/charmbracelet/bubbles/textarea" // For multiline text editing.
	tea "github.com/charmbracelet/bubbletea"    // Bubble Tea TUI framework.
	"github.com/charmbracelet/lipgloss"         // For styling terminal output.
	"github.com/rs/zerolog/log"                 // For debug logging.

	"github.com/renatogalera/ai-commit/pkg/ai"          // AI client interface.
	"github.com/renatogalera/ai-commit/pkg/committypes" // Commit types and regex helpers.
	"github.com/renatogalera/ai-commit/pkg/git"         // Git operations.
	"github.com/renatogalera/ai-commit/pkg/prompt"      // Prompt builder.
	"github.com/renatogalera/ai-commit/pkg/template"    // Template processing.
)

// uiState represents the various states the TUI can be in.
type uiState int

const (
	stateShowCommit    uiState = iota // Show the current commit message.
	stateGenerating                   // Currently waiting for the AI to regenerate.
	stateCommitting                   // Waiting for the commit command to finish.
	stateResult                       // Final result state (success or error).
	stateSelectType                   // UI for selecting commit type.
	stateEditing                      // UI for editing the commit message.
	stateEditingPrompt                // UI for editing the prompt text.
)

// Internal message types used for Bubble Tea updates.
type (
	commitResultMsg struct{ err error } // Returned after commit is attempted.
	regenMsg        struct {            // Returned after regeneration from AI.
		msg string
		err error
	}
	autoQuitMsg struct{} // Used to signal auto-quit after a short delay.
)

// Define some lipgloss styles for the UI elements.
var (
	titleStyle = lipgloss.NewStyle().
			Bold(true).
			Foreground(lipgloss.Color("205")) // A pinkish color.

	commitBoxStyle = lipgloss.NewStyle().
			BorderStyle(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.Color("63")). // Soft blue.
			Padding(1, 2).
			Margin(1, 0)

	helpBoxStyle = lipgloss.NewStyle().
			BorderStyle(lipgloss.NormalBorder()).
			BorderForeground(lipgloss.Color("63")).
			Padding(1, 2).
			Margin(1, 0)

	highlightStyle = lipgloss.NewStyle().
			Foreground(lipgloss.Color("212")). // Pink.
			Bold(true)
)

// Model holds the complete state of the TUI.
type Model struct {
	// Current UI state.
	state uiState

	// The commit message generated by the AI.
	commitMsg string

	// The final result message (e.g. commit succeeded or an error message).
	result string

	// Spinner for loading animations.
	spinner spinner.Model

	// Git diff used for generating the commit message.
	diff string

	// Language in which the commit message is generated.
	language string

	// The AI prompt text (including the diff and additional context).
	prompt string

	// Commit type (e.g., "feat", "fix", etc.).
	commitType string

	// Template to apply to the generated commit message.
	template string

	// Whether to include an emoji in the commit message.
	enableEmoji bool

	// The AI client used for generating commit messages.
	aiClient ai.AIClient

	// For commit type selection.
	selectedIndex int
	commitTypes   []string

	// Counters for regeneration attempts.
	regenCount int
	maxRegens  int

	// Textarea for editing commit messages or prompt text.
	textarea textarea.Model
}

// renderHeader creates a decorative ASCII header for the TUI.
func renderHeader() string {
	return titleStyle.Render(`
    AI-Commit TUI
`)
}

// NewUIModel constructs and returns a new Model with the given parameters.
func NewUIModel(commitMsg, diff, language, promptText, commitType, tmpl string, enableEmoji bool, client ai.AIClient) Model {
	// Initialize spinner with a dot style.
	s := spinner.New()
	s.Spinner = spinner.Dot

	// Initialize textarea with default settings.
	ta := textarea.New()
	ta.Placeholder = "Edit your commit message or additional prompt here..."
	ta.Prompt = "> "
	ta.SetWidth(50)
	ta.SetHeight(10)
	ta.ShowLineNumbers = false

	return Model{
		state:         stateShowCommit,
		commitMsg:     commitMsg,
		diff:          diff,
		language:      language,
		prompt:        promptText,
		commitType:    commitType,
		template:      tmpl,
		enableEmoji:   enableEmoji,
		aiClient:      client,
		spinner:       s,
		selectedIndex: 0,
		commitTypes:   committypes.AllTypes(),
		regenCount:    0,
		maxRegens:     3,
		textarea:      ta,
	}
}

// NewProgram initializes and returns a new Bubble Tea program using the provided model.
// It also enables an alternative screen (full-screen TUI).
func NewProgram(m Model) *tea.Program {
	return tea.NewProgram(m, tea.WithAltScreen())
}

// Init is part of the Bubble Tea interface and returns an initial command (none here).
func (m Model) Init() tea.Cmd {
	return nil
}

// Update handles messages and events, updating the TUI state accordingly.
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmd tea.Cmd

	switch msg := msg.(type) {
	case tea.KeyMsg:
		// Process key messages based on current state.
		switch m.state {
		case stateShowCommit:
			switch msg.String() {
			case "y", "enter":
				// User accepts the commit message.
				m.state = stateCommitting
				return m, commitCmd(m.commitMsg)
			case "r":
				// User requests regeneration.
				if m.regenCount >= m.maxRegens {
					m.result = fmt.Sprintf("Maximum regenerations (%d) reached.", m.maxRegens)
					m.state = stateResult
					return m, autoQuitCmd()
				}
				m.state = stateGenerating
				// Reset spinner.
				m.spinner = spinner.New()
				m.spinner.Spinner = spinner.Dot
				m.regenCount++
				return m, regenCmd(m.aiClient, m.prompt, m.commitType, m.template, m.enableEmoji)
			case "q", "ctrl+c":
				return m, tea.Quit
			case "t":
				// Change commit type.
				m.state = stateSelectType
				return m, nil
			case "e":
				// Edit commit message.
				m.state = stateEditing
				m.textarea.SetValue(m.commitMsg)
				m.textarea.Focus()
				return m, nil
			case "p":
				// Edit the prompt text.
				m.state = stateEditingPrompt
				m.textarea.SetValue("")
				m.textarea.Focus()
				return m, nil
			}

		case stateSelectType:
			switch msg.String() {
			case "q", "esc", "ctrl+c":
				m.state = stateShowCommit
				return m, nil
			case "up", "k":
				if m.selectedIndex > 0 {
					m.selectedIndex--
				}
			case "down", "j":
				if m.selectedIndex < len(m.commitTypes)-1 {
					m.selectedIndex++
				}
			case "enter":
				// Set selected commit type and regenerate message.
				m.commitType = m.commitTypes[m.selectedIndex]
				m.state = stateGenerating
				m.spinner = spinner.New()
				m.spinner.Spinner = spinner.Dot
				m.regenCount++
				m.prompt = prompt.BuildPrompt(m.diff, m.language, m.commitType, "")
				return m, regenCmd(m.aiClient, m.prompt, m.commitType, m.template, m.enableEmoji)
			}

		case stateEditing:
			// Process key events for commit message editing.
			var tcmd tea.Cmd
			m.textarea, tcmd = m.textarea.Update(msg)
			cmd = tcmd
			switch msg.String() {
			case "esc":
				// Cancel editing and return to showing the commit.
				m.state = stateShowCommit
				return m, cmd
			case "ctrl+s":
				// Save the edited commit message.
				m.commitMsg = m.textarea.Value()
				m.state = stateShowCommit
				return m, cmd
			}
			return m, cmd

		case stateEditingPrompt:
			// Process key events for prompt editing.
			var tcmd tea.Cmd
			m.textarea, tcmd = m.textarea.Update(msg)
			cmd = tcmd
			switch msg.String() {
			case "esc":
				m.state = stateShowCommit
				return m, cmd
			case "ctrl+s":
				// Save the additional prompt text and regenerate message.
				userPrompt := m.textarea.Value()
				m.state = stateGenerating
				m.spinner = spinner.New()
				m.spinner.Spinner = spinner.Dot
				m.regenCount++
				m.prompt = prompt.BuildPrompt(m.diff, m.language, m.commitType, userPrompt)
				return m, regenCmd(m.aiClient, m.prompt, m.commitType, m.template, m.enableEmoji)
			}
			return m, cmd
		}

	case regenMsg:
		// Process regeneration message from AI.
		log.Debug().Msgf("regenMsg received with commit message: %q", msg.msg)
		if msg.err != nil {
			m.result = fmt.Sprintf("Error: %v", msg.err)
			m.state = stateResult
			return m, autoQuitCmd()
		}
		m.commitMsg = msg.msg
		m.state = stateShowCommit
		return m, nil

	case commitResultMsg:
		// Process result of the commit operation.
		if msg.err != nil {
			m.result = fmt.Sprintf("Commit failed: %v", msg.err)
		} else {
			m.result = "Commit created successfully!"
		}
		m.state = stateResult
		return m, autoQuitCmd()

	case autoQuitMsg:
		// Signal to quit the TUI.
		return m, tea.Quit

	case spinner.TickMsg:
		// Update spinner when in generating or committing state.
		if m.state == stateGenerating || m.state == stateCommitting {
			m.spinner, cmd = m.spinner.Update(msg)
			return m, cmd
		}
	}

	// For states that do not use the textarea, no extra update is needed.
	return m, cmd
}

// View renders the TUI based on the current state.
func (m Model) View() string {
	switch m.state {
	case stateShowCommit:
		// Render header, commit message box, and help instructions.
		header := renderHeader()
		commitBox := commitBoxStyle.Render(m.commitMsg)
		helpText := highlightStyle.Render(
			"Press 'y' to commit, 'r' to regenerate,\n" +
				"'e' to edit, 't' to change type,\n" +
				"'p' to add prompt text, 'q' to quit.",
		)
		helpBox := helpBoxStyle.Render(helpText)
		return lipgloss.JoinVertical(lipgloss.Left, header, commitBox, helpBox)

	case stateGenerating:
		return fmt.Sprintf("Generating commit message... %s", m.spinner.View())

	case stateCommitting:
		return fmt.Sprintf("Committing... %s", m.spinner.View())

	case stateResult:
		return m.result

	case stateSelectType:
		var b strings.Builder
		b.WriteString("Select commit type:\n\n")
		for i, ct := range m.commitTypes {
			cursor := " "
			if i == m.selectedIndex {
				cursor = ">"
			}
			b.WriteString(fmt.Sprintf("%s %s\n", cursor, ct))
		}
		b.WriteString("\nUse ↑/↓ (or j/k) to navigate, Enter to select, 'q' to cancel.\n")
		return b.String()

	case stateEditing:
		return fmt.Sprintf("Editing commit message (ESC to cancel, Ctrl+S to save):\n\n%s", m.textarea.View())

	case stateEditingPrompt:
		return fmt.Sprintf("Editing prompt text (ESC to cancel, Ctrl+S to apply):\n\n%s", m.textarea.View())
	}
	return ""
}

// commitCmd triggers the Git commit operation with a given commit message.
func commitCmd(commitMsg string) tea.Cmd {
	return func() tea.Msg {
		ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
		defer cancel()
		err := git.CommitChanges(ctx, commitMsg)
		return commitResultMsg{err: err}
	}
}

// regenCmd calls the AI to regenerate the commit message and returns a regenMsg.
func regenCmd(client ai.AIClient, prompt, commitType, tmpl string, enableEmoji bool) tea.Cmd {
	return func() tea.Msg {
		msg, err := regenerate(prompt, client, commitType, tmpl, enableEmoji)
		return regenMsg{msg: msg, err: err}
	}
}

// regenerate calls the AI client to generate a new commit message, then sanitizes and
// applies any template or emoji rules.
func regenerate(prompt string, client ai.AIClient, commitType, tmpl string, enableEmoji bool) (string, error) {
	ctx, cancel := context.WithTimeout(context.Background(), 60*time.Second)
	defer cancel()

	log.Debug().Msg("Calling GetCommitMessage on AI client")
	result, err := client.GetCommitMessage(ctx, prompt)
	if err != nil {
		log.Error().Err(err).Msg("GetCommitMessage returned an error")
		return "", err
	}
	log.Debug().Msg("Received response from AI client")

	// Sanitize the AI output.
	result = ai.SanitizeResponse(result, commitType)
	if enableEmoji {
		result = git.AddGitmoji(result, commitType)
	}
	if tmpl != "" {
		result, err = template.ApplyTemplate(tmpl, result)
		if err != nil {
			return "", err
		}
	}
	return result, nil
}

// autoQuitCmd issues a command to automatically quit after a 2-second delay.
func autoQuitCmd() tea.Cmd {
	return tea.Tick(2*time.Second, func(_ time.Time) tea.Msg {
		return autoQuitMsg{}
	})
}
